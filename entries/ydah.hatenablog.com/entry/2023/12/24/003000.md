---
Title: Ruby構文解析器 開発日録#2
Date: 2023-12-24T00:30:00+09:00
URL: https://ydah.hatenablog.com/entry/2023/12/24/003000
EditURL: https://blog.hatena.ne.jp/ydah/ydah.hatenablog.com/atom/entry/6801883189109183414
---

[昨日](https://ydah.net/blog/posts/20231223)に引き続き筆を執っています。今日はクリスマスイブですね。

さて、今回は[ANDPAD Advent Calendar 2023](https://qiita.com/advent-calendar/2023/andpad)の24日目の記事として、今年[Lrama](https://github.com/ruby/lrama)の開発で手を動かしてきた内容の中で、これまで発表していないものを紹介します[^1]。もうすぐ今年も終わりますので、いわゆる「今年の振り返り」となる内容です。

今年はどれくらい手を動かしたかというと[大体140コミット](https://github.com/ruby/lrama/graphs/contributors?from=2022-12-25&to=2023-12-25&type=c)ほどでした。[^2]
グラフを眺めていると[Kaigi on Rails 2023](https://kaigionrails.org/2023/)、[RubyWorld Conference 2023](https://2023.rubyworld-conf.org/ja/)辺りでKaigi Effectを受けていることが目に見えるので、とてもおもしろいですね。それでは、振り返りをしていきましょう。

## #includeを明示しなくていいようにする

- [Change to automatically insert #include of header files when they are specified #104](https://github.com/ruby/lrama/pull/104)

[Bison](https://www.gnu.org/software/bison/)との差分を解消した対応です。Bisonはヘッダーファイルを生成するオプションをつけると、`#include`を明示しなくてもヘッダーファイルをインクルードしてくれます。
これをLramaでも同じ挙動にするために、`-h`、`--header`、`-d`オプションをつけた場合には、`#include`を明示しなくてもヘッダーファイルをインクルードするようにしました。

たとえば、以下のコマンドを実行したとします。

```command
lrama calc.y --header=calc.h -o calc.c
```

この場合、`calc.y`から`calc.c`と`calc.h`が生成されますが、`calc.y`において以下のように`#include "calc.h"`を明示する必要がなくなりました。

```diff
#include <stdlib.h>
#include <ctype.h>

-#include "calc.h"

static int yylex(YYSTYPE *val, YYLTYPE *loc);
static int yyerror(YYLTYPE *loc, const char *str);
```

今までは`#include`ディレクティブにヘッダーファイルの名前を決め打ちで書く必要があったので、コマンドを以下のように変更するとたちまちコンパイルエラーになってしまっていました。[^3]

```command
lrama calc.y --header=other.h -o calc.c
```

## Helpコマンドの改善

- [Improve output when executing the help command #97](https://github.com/ruby/lrama/pull/97)
- [Add description of STDIN mode to help command #124](https://github.com/ruby/lrama/pull/124)

Lramaに文法ファイルを渡して色々と試していた時に、どんなオプションがあるのだろうと思っておもむろに`lrama --help`を実行したところ、以下のような出力がされていました。

```command
❯ lrama --help
Usage: lrama [options]
    -V, --version
    -S, --skeleton=FILE
    -t
    -h, --header=[FILE]
    -d
    -r, --report=THINGS
        --report-file=FILE
    -v
    -o, --output=FILE
        --trace=THINGS
    -e
```

Bisonのオプションと概ね同じ意味になっているとは思いましたが、`--help`コマンドを実行した時に、どんなオプションがあるのかを一目でわかるようにするために、オプションを整理して表示するようにしました。

```command
❯ lrama --help
Lrama is LALR (1) parser generator written by Ruby.

Usage: lrama [options] FILE

STDIN mode:
lrama [options] - FILE               read grammar from STDIN

Tuning the Parser:
    -S, --skeleton=FILE              specify the skeleton to use
    -t                               reserved, do nothing

Output:
    -h, --header=[FILE]              also produce a header file named FILE
    -d                               also produce a header file
    -r, --report=THINGS              also produce details on the automaton
        --report-file=FILE           also produce details on the automaton output to a file named FILE
    -o, --output=FILE                leave output to FILE
        --trace=THINGS               also output trace logs at runtime
    -v                               reserved, do nothing

Error Recovery:
    -e                               enable error recovery

Other options:
    -V, --version                    output version information and exit
        --help                       display this help and exit
```

そして、`--help`コマンドを整理していて気づいたのですが、いくつかreservedになっているのみのオプションもあったので、整理しておいて良かったと感じました。
また、この副産物としてBisonとのオプションの差異に気づくこともできました。

具体的には生成するヘッダファイルを生成するのためのオプションは`-H`なのですが、Lramaでは`-h`となっていました。
これは段階的に、`-H`オプションへと移行していて、v0.5.8以降のLramaではBisonとの差異は解消しています。

## エラーメッセージの改善

- [Improve an error message for ParseError #155](https://github.com/ruby/lrama/pull/155)
- [Improve error message for action](https://github.com/ruby/lrama/pull/207)
- [Add the starting position to the location information](https://github.com/ruby/lrama/pull/185)

Lramaはv0.5.7から、内部に持っている手書きパーサーが、Raccによる自動生成したものに置き換わりました[^4]。つまり、[parser.y](https://github.com/ruby/lrama/blob/master/parser.y)という文法ファイルから[parser.rb](https://github.com/ruby/lrama/blob/master/lib/lrama/parser.rb)を生成するように変わりました。
それに伴い、内部パーサーで文法ファイルを解析する際に、もしパースエラーが発生した場合には[Raccが提供しているon_errorでerror_valueから情報がとれる](https://github.com/ruby/racc/blob/master/doc/ja/parser.ja.rdoc)のでエラーメッセージがリッチにできます。

なので、パースエラーが発生した場合に、以下のようにファイル名と位置情報とエラーが発生した周辺をエラーメッセージとして表示するようにしています。

```command
❯ lrama -d test.y
parser.y:400:in `on_error': a.y:5:7: parse error on value #<struct Lrama::Lexer::Token::Ident s_value="invalid", alias_name=nil> (IDENTIFIER) (Racc::ParseError)
%expect invalid
        ^^^^^^^
        from racc/parser.rb:276:in `_racc_do_parse_c'
        from racc/parser.rb:276:in `do_parse'
        from parser.y:386:in `block in parse'
        from /ydah/lrama/lib/lrama/report/duration.rb:14:in `report_duration'
        from parser.y:381:in `parse'
        from /ydah/lrama/lib/lrama/command.rb:11:in `run'
        from lrama:6:in `<main>'
```

これによって、よりエラーとなった位置が分かりやすくなり、開発の体験を少しでもよくすることができたのではないかと思っています。
また、Lramaの内部でいくつか残っていた`raise`だけしていた箇所も、それぞれ例外が発生した理由を追加しています。（すべて倒しきったはずです）

- [Add to the message what kind of unexpected input it is #186](https://github.com/ruby/lrama/pull/186)

## パフォーマンスの改善

- [Improved lexer speed #243](https://github.com/ruby/lrama/pull/243)

Profileによると[lexer](https://github.com/ydah/lrama/blob/master/lib/lrama/lexer.rb)がそれなりに重かったです。
Lexerでは[StringScanner](https://docs.ruby-lang.org/ja/latest/class/StringScanner.html)を使って文法ファイルを読んでトークン列に分割していっているのですが、[StringScanner#getch](https://docs.ruby-lang.org/ja/latest/method/StringScanner/i/getch.html)で一文字ずつ読んでいる箇所があり、ここがボトルネックになっているようでした。なので、[StringScanner#scan](https://docs.ruby-lang.org/ja/latest/method/StringScanner/i/scan.html)で読めるところまで1回で読んでしまうように変更しました。

この変更によって、約30%ほど処理時間が改善しています。

### Before

```command
❯ lrama --trace=time -o parse.tmp.c --header=parse.tmp.h parse.tmp.y
parse    4.38929 s
compute_lr0_states    0.88006 s
compute_direct_read_sets    0.06813 s
compute_reads_relation    0.01174 s
compute_read_sets    0.04809 s
compute_includes_relation    0.72033 s
compute_lookback_relation    1.40715 s
compute_follow_sets    0.12471 s
compute_look_ahead_sets    1.00162 s
compute_conflicts    0.06503 s
compute_default_reduction    0.00617 s
compute_yydefact    0.08520 s
compute_yydefgoto    0.07973 s
sort_actions    0.00674 s
compute_packed_table    0.41180 s
render    0.09383 s
```

### After

```command
❯ lrama --trace=time -o parse.tmp.c --header=parse.tmp.h parse.tmp.y
parse    0.93149 s
compute_lr0_states    0.90139 s
compute_direct_read_sets    0.07115 s
compute_reads_relation    0.01218 s
compute_read_sets    0.04671 s
compute_includes_relation    0.69610 s
compute_lookback_relation    1.35323 s
compute_follow_sets    0.11844 s
compute_look_ahead_sets    1.01038 s
compute_conflicts    0.06607 s
compute_default_reduction    0.00666 s
compute_yydefact    0.08754 s
compute_yydefgoto    0.08042 s
sort_actions    0.00655 s
compute_packed_table    0.45709 s
render    0.08769 s
```

stackprofで見ても以下の通り、`Lrama::Lexer#lex_c_code`という今回修正したメソッドの速度が改善した[^5]ことが分かります。

### Before

```command
❯ bundle exec stackprof --limit 10 tmp/stackprof-cpu-myapp.dump
==================================
  Mode: cpu(1000)
  Samples: 6449 (3.30% miss rate)
  GC: 1784 (27.66%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
      1858  (28.8%)        1858  (28.8%)     (sweeping)
      1305  (20.2%)        1216  (18.9%)     Lrama::Lexer#lex_c_code
       531   (8.2%)         371   (5.8%)     Struct#==
       785  (12.2%)         339   (5.3%)     Lrama::States#compute_look_ahead_sets
       294   (4.6%)         252   (3.9%)     Lrama::Context#compute_packed_table
       192   (3.0%)         192   (3.0%)     Integer#>>
       186   (2.9%)         186   (2.9%)     Integer#&
       188   (2.9%)         158   (2.4%)     Lrama::Lexer::Token#==
      3027  (46.9%)         147   (2.3%)     Array#each
       637   (9.9%)         138   (2.1%)     Lrama::States#compute_lookback_relation
```

### After

```command
❯ bundle exec stackprof --limit 10 tmp/stackprof-cpu-myapp.dump
==================================
  Mode: cpu(1000)
  Samples: 3711 (0.51% miss rate)
  GC: 186 (5.01%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
       797  (21.5%)         338   (9.1%)     Lrama::States#compute_look_ahead_sets
       474  (12.8%)         307   (8.3%)     Struct#==
       329   (8.9%)         290   (7.8%)     Lrama::Context#compute_packed_table
       246   (6.6%)         240   (6.5%)     Lrama::Lexer#lex_c_code
       191   (5.1%)         191   (5.1%)     Integer#>>
       180   (4.9%)         180   (4.9%)     Integer#&
       187   (5.0%)         157   (4.2%)     Lrama::Lexer::Token#==
       592  (16.0%)         146   (3.9%)     Lrama::States#compute_lookback_relation
      3037  (81.8%)         138   (3.7%)     Array#each
       137   (3.7%)         137   (3.7%)     Lrama::States::Item#hash
```

## さいごに

今回、紹介したものは細々とした対応が多かったかもしれないですが、少しずつでもLramaをより良くしていけたのではないかと思っています。
昨日の記事で紹介したParameterizing rulesの実装も着々と進んでいて、parse.yをより読みやすく理解しやすいものにしていくというゴールに向けて、着実に進んでいると感じています。来年も引き続きやっていきたいと思っているので、よろしくお願いします。

[^1]: [4日ほど前にまったく同じコンセプトの記事](https://tech.andpad.co.jp/entry/2023/12/20/100000)がありましたね。
[^2]: 実際に活発に開発をしだしたのは8月頃からなので、実質4か月ほどです。
[^3]: [ruby/ruby](https://github.com/ruby/ruby)においては対応前のLramaでもbuildに成功していたのでブロッカーにはなっていなかったですが、ヘッダーファイルの名前を決め打ちで書く必要がなくなるのは良いので、この対応を行いました。
[^4]: こばじゅんさん([@junk0612](https://twitter.com/junk0612))の[偉業です](https://github.com/ruby/lrama/pull/62)。この変更により文法の追加が非常にやりやすくなりました。
[^5]: 変更行はごく僅かですが結果としてあらわれると、とても気持ちいいですね。
