---
Title: 正規表現の季節と聞いて、正規表現エンジンを作ってみた
Date: 2025-08-27T01:14:41+09:00
URL: https://ydah.hatenablog.com/entry/2025/08/27/011441
EditURL: https://blog.hatena.ne.jp/ydah/ydah.hatenablog.com/atom/entry/6802418398564353216
---

[Kernel/VM探検隊@関西 11回目](https://kernelvm.connpass.com/event/347564/)や、[Nextbeat Tech Bar： 楽しい正規表現](https://nextbeat.connpass.com/event/357700/)に参加して、どうやら人間は正規表現エンジンを作っているらしいということを知り、私も作ってみたいという気持ちが高まったので正規表現エンジンを作ってみた。

どうやら「[秋から冬は正規表現の季節](https://docs.google.com/presentation/d/10klRIASTVr_LUoPBNQHxQE-T5rYDI7L4BH6elyRx948/edit?slide=id.g340c2db8966_0_79#slide=id.g340c2db8966_0_79)」なのだそうだ。しかし、少し待ってほしい。今は夏ではないか？いや、本当にそうだろうか？

>立秋（りっしゅう）は、二十四節気の第13。七月節（旧暦6月後半から7月前半）。
>現在広まっている定気法では太陽黄経が135度のときで8月7日ごろ。暦ではそれが起こる日だが、天文学ではその瞬間とする。恒気法では冬至から5/8年（約228.28日）後で8月8日ごろ。

参照: https://ja.wikipedia.org/wiki/%E7%AB%8B%E7%A7%8B

というわけで、暦の上では今は秋と言えるだろう。そう、「正規表現エンジンの秋」である。ということで、正規表現エンジンを作ってみた。

## 成果物

[https://github.com/ydah/hoozuki:embed:cite]

鬼灯（ほおずき）という名前の正規表現エンジン。OnigurumaやOnigmoのように「鬼」の文字を入れたいと思っていて、お盆の時期に書き始めたので鬼灯にした。
何かを作ろうと思った時に、良い名前が思い浮かばないと手を動かせないのを何とかしたい。ゲームでも主人公の名前で悩んで数時間が溶けることがザラにあるのが悩みだ。

- Ruby製の正規表現エンジン
- 2つのエンジンを切り替え可能
  - DFAベースのエンジン
  - VMベースのエンジン
- サポートしている正規表現の機能
  - 文字
  - 連結
  - 選択
  - 繰り返し
  - グループ化

## 使い方

DFAベースのエンジンを使う場合

```ruby
require 'hoozuki'
regex = Hoozuki.new('a(bc|de)*f')
regex.match?('abcdef') # => true
regex.match?('adef')   # => true
regex.match?('xyz')    # => false
```

VMベースのエンジンを使う場合

```ruby
require 'hoozuki'
regex = Hoozuki.new('a(bc|de)*f', engine: :vm)
regex.match?('abcdef') # => true
regex.match?('adef')   # => true
regex.match?('xyz')    # => false
```

## 正規表現エンジンとは？

正規表現エンジンとは、正規表現を入力として受け取って、文字列がその正規表現にマッチするかどうかを判定するエンジンのこと。
たとえば、正規表現 `a(bc|de)*f` は、`a` に続いて `bc` または `de` が0回以上繰り返され、その後に `f` が続く文字列にマッチする。したがって、`abcdef` や `adef` はこの正規表現にマッチするが、`xyz` はマッチしない。

## パーサー

正規表現エンジンを作るためには、まず正規表現を解析して内部的な表現に変換するパーサーが必要。再帰下降パーサーを実装して、正規表現を抽象構文木（AST）に変換している。正規表現の優先順位を反映した階層的なアプローチで解析を行っている

1. Choice (選択): 最も低い優先順位の演算子である `|` を処理
2. Concatenation (連結): 暗黙的な連結を処理（例: `ab` は `a` と `b` の連結）
3. Repetition (繰り返し): `*`, `+`, `?` を処理
4. Grouping (グループ化): `(` と `)` を処理
5. Literal (リテラル): 文字やエスケープシーケンスを処理

今回はパーサーの実装はメインではないので、[@makenowjust](https://github.com/makenowjust)さんの[kantan-regex](https://github.com/makenowjust/kantan-regex-book)の実装を参考にしました。この程度の正規表現の文法であれば、再帰下降パーサーでも簡単に実装できますね。

## DFAベースのエンジン

正規表現をDFA（Deterministic Finite Automaton、決定性有限オートマトン）に変換してマッチングを行うエンジン。DFAは、入力文字列を1文字ずつ読み進めながら状態遷移を行い、最終的に受理状態[^1]に到達するかどうかでマッチングを判定する。
[^1]: 受理状態とは、オートマトンが入力文字列を完全に読み終えたときに、その文字列が正規表現にマッチすることを示す状態のこと。
DFAベースのエンジンは、入力文字列の長さに対して線形時間でマッチングを行うことができるため、高速なマッチングが可能。ただし、DFAの状態数が指数関数的に増加する可能性があるため、メモリ使用量が大きくなることがある。
また、DFAはバックトラッキングを行わないため、正規表現の一部の機能（例: 後読み、条件付き表現など）をサポートできないことが特徴である。

## DFAへの変換手順

DFAの構築には、まず正規表現をThompsonの構成法(Thompson's construction)を用いてNFA（Nondeterministic Finite Automaton、非決定性有限オートマトン）に変換し、その後NFAをDFAに変換する。NFAからDFAへの変換は、部分集合構成法(subset construction)を使用している。

### Thompsonの構成法を使ってNFAを構築する

Thompsonの構成法は、正規表現をNFAに変換するアルゴリズム。基本的な正規表現の要素（文字、連結、選択、繰り返し）に対して、それぞれ対応するNFAの構造を定義し、これらを組み合わせて複雑な正規表現に対応するNFAを構築する。

たとえば、Literalは以下の様なNFAとすれば良い。

<figure class="figure-image figure-image-fotolife" title="LiteralのNFA">[f:id:ydah:20250827011303p:plain]<figcaption>LiteralのNFA</figcaption></figure>

実装は次のようになる。

```ruby
class Hoozuki
  module Automaton
    class NFA
      def new_from_node(node, state)
        case node
        when Node::Literal
          start_state = state.new_state
          accept_state = state.new_state
          nfa = new(start_state, [accept_state])
          nfa.add_transition(start_state, node.value, accept_state)
          nfa
        # 他のノードタイプに対する処理
        end
      end
    end
  end
end
```

Epsilonは空文字にマッチする遷移を表すので、以下の様なNFAとすれば良い。

<figure class="figure-image figure-image-fotolife" title="EpsilonのNFA">[f:id:ydah:20250827011329p:plain]<figcaption>EpsilonのNFA</figcaption></figure>

実装は次のようになる。

```ruby
class Hoozuki
  module Automaton
    class NFA
      def new_from_node(node, state)
        case node
        when Node::Epsilon
          start_state = state.new_state
          accept_state = state.new_state
          nfa = new(start_state, [accept_state])
          nfa.add_epsilon_transition(start_state, accept_state)
          nfa
        # 他のノードタイプに対する処理
        end
      end
    end
  end
end
```

Choiceは2つのNFAを選択肢として持つので、以下の様なNFAとすれば良い。

<figure class="figure-image figure-image-fotolife" title="ChoiceのNFA">[f:id:ydah:20250827011345p:plain]<figcaption>ChoiceのNFA</figcaption></figure>

実装は次のようになる。

```ruby
class Hoozuki
  module Automaton
    class NFA
      def new_from_node(node, state)
        case node
        when Node::Choice
          remain1 = new_from_node(node.children[0], state)
          remain2 = new_from_node(node.children[1], state)
          start_state = state.new_state
          accepts = remain1.accept if remain1.respond_to?(:accept)
          accepts |= remain2.accept if remain2.respond_to?(:accept)
          nfa = new(start_state, accepts)
          nfa.merge_nfa(remain1)
          nfa.merge_nfa(remain2)
          nfa.add_epsilon_transition(start_state, remain1.start)
          nfa.add_epsilon_transition(start_state, remain2.start)
          nfa
        # 他のノードタイプに対する処理
        end
      end
    end
  end
end
```
これらのパーツを組み合わせて、NFAを構築していく。

### 部分集合構成法を使ってNFAをDFAに変換する

部分集合構成法は、NFAをDFAに変換するアルゴリズム。NFAの状態の集合をDFAの状態として扱い、NFAの遷移を基にDFAの遷移を定義することで、NFAの非決定性を解消し、決定性を持つDFAを構築する。DFAに変換するには、等価性を保ったまま非決定性を解消する必要がある。

なぜ、DFAに変換した方が良いかというとDFAの最大の特徴は状態が一意に決まることです。NFAと違って複数の可能性を同時に考慮する必要がないため、入力文字列を1文字ずつ読み進めながら状態遷移を行うことができます。
また、入力文字列のサイズに対して線形時間 O(n) でマッチングを行うことができるため、高速なマッチングが可能です。

まずは、開始状態の構築をします。

```ruby
start_set = Set.new([nfa.start])
start_states = nfa.epsilon_closure(start_set)

start_id = 0
dfa_states[start_states] = start_id
queue << start_states

dfa = new(start_id, Set.new)
```

ここでは、ε-closureを計算して、NFAの開始状態からε遷移で到達可能な状態の集合を求めています。この集合がDFAの開始状態となります。

続いて、BFSによる状態構築を行います。

```ruby
while (current_nfa_states = queue.shift)
  current_dfa_id = dfa_states[current_nfa_states]
  dfa.accept.merge([current_dfa_id]) if current_nfa_states.any? { |state| nfa_accept_set.include?(state) }

  transitions_map = Hash.new { |h, k| h[k] = Set.new }

  current_nfa_states.each do |state|
    nfa.transitions.each do |from, label, to|
      transitions_map[label].merge(nfa.epsilon_closure(Set[to])) if from == state && !label.nil?
    end
  end

  transitions_map.each do |char, next_nfa_states|
    unless dfa_states.key?(next_nfa_states)
      next_dfa_id = dfa_states.length
      dfa_states[next_nfa_states] = next_dfa_id
      queue.push(next_nfa_states)
    end

    next_dfa_id = dfa_states[next_nfa_states]
    dfa.transitions.add([current_dfa_id, char, next_dfa_id])
    # ...
  end
end
```

まず受理状態の判定を行い、NFA状態集合に1つでも受理状態が含まれていれば、対応するDFA状態を受理状態に追加します。
次に遷移の収集を行い、各NFA状態からの遷移を調査し、同じ入力文字に対する遷移先のNFA状態をまとめます。
最後に、新状態の作成と遷移の追加を行います。

これで、NFAからDFAへの変換が完了します。最後に、DFAを使ってマッチングを行います。

```ruby
def match?(input, use_cache)
  state = @start

  input.each_char do |char|
    next_state = next_transition(state, char, use_cache)
    return false unless next_state

    state = next_state
  end

  @accept.include?(state)
end
```

DFAの開始状態から始めて、入力文字列を1文字ずつ読み進めながら状態遷移を行います。各文字に対して、現在の状態と入力文字に基づいて次の状態を取得し、次の状態が存在しない場合はマッチング失敗とします。すべての文字を処理した後、最終的な状態が受理状態に含まれているかどうかでマッチング結果を判定します。

## VMベースのエンジン

正規表現をバイトコードにコンパイルし、そのバイトコードを仮想マシン上で実行してマッチングを行うエンジン。VMベースのエンジンは、バックトラッキングを利用して複雑な正規表現のマッチングをサポートすることができるのが特徴。VMベースのエンジンは、DFAベースのエンジンと比較して、メモリ使用量が少なく、正規表現の一部の機能（例: 後読み、条件付き表現など）をサポートできる。ただし、バックトラッキングを利用するため、最悪の場合に指数関数的な時間がかかることがある。

### バイトコードの命令セット

今回の要件であれば命令セットは以下の4つで十分。

- `Char`: 1文字を消費して次の状態に遷移
- `Split`: 2つの分岐を作成して、どちらかに遷移
- `Jump`: 無条件に指定された命令にジャンプ
- `Match`: マッチするか判定する

それぞれをクラスとして定義しておく。

```ruby
class Hoozuki
  module Instruction
    class Char
      attr_accessor :char

      def initialize(char)
        @char = char
      end
    end
  end
end
```

### 命令の生成と書き換えのヘルパー

ヘルパーメソッドを用意して、命令の追加と後から命令を書き換えるための仕組みを実装する。

```ruby
def emit(instruction)
  @instructions << instruction  # 命令を追加
  @pc += 1                     # プログラムカウンタをインクリメント
end

def patch(pc, instruction)
  @instructions[pc] = instruction  # 後から命令を書き換え（前方参照の解決）
end
```
### バイトコードの生成

あとは、パーサーで生成したASTを走査して、対応する命令を生成していく。

```ruby
def _compile(ast)
  case ast
  when Hoozuki::Node::Literal
    emit(Hoozuki::Instruction::Char.new(ast.value)) # 文字にマッチする命令を追加
  when Hoozuki::Node::Epsilon
    # Epsilonは何もしない
  when Node::Choice
    split = @pc
    @pc += 1
    @instructions << Hoozuki::Instruction::Split.new(@pc, 0) # 仮の命令を追加
    _compile(ast.children.first) # 左側の子ノードをコンパイル
    jump = @pc
    emit(Hoozuki::Instruction::Jmp.new(0)) # 仮の命令を追加
    unless @instructions[split].is_a?(Hoozuki::Instruction::Split)
      raise "Instruction at pc #{split} is not a Split"
    end
    @instructions[split].right = @pc # Split命令の右側のターゲットを設定
    _compile(ast.children.last) # 右側の子ノードをコンパイル
    raise "Instruction at pc #{jump} is not a Jmp" unless @instructions[jump].is_a?(Hoozuki::Instruction::Jmp)
    @instructions[jump].target = @pc # Jmp命令のターゲットを設定
  # 他のノードタイプに対する処理
  end
end
```

### バイトコードの実行

バイトコードを実行する仮想マシンを実装する。スタックを用いて状態を管理し、命令を順次実行していく。

```ruby
def _evaluate(instructions, input, input_pos, pc)
  loop do
    return false if pc >= instructions.size # プログラムカウンタが命令の範囲外なら失敗
    inst = instructions[pc]
    case inst
    when Hoozuki::Instruction::Char
      return false if input_pos >= input.size || input[input_pos] != inst.char # 文字が一致しない場合は失敗
      input_pos += 1
      pc += 1
    when Hoozuki::Instruction::Jmp
      pc = inst.target # 無条件ジャンプ
    when Hoozuki::Instruction::Split
      return true if _evaluate(instructions, input, input_pos, inst.left) # 左の分岐を試す
      pc = inst.right # 右の分岐に進む
    when Hoozuki::Instruction::Match
      return input_pos == input.length # 入力全体を消費していれば成功
    else
      raise "Unknown instruction: #{inst.class}"
    end
  end
end
```

Match命令に到達した場合、入力文字列全体を消費していればマッチ成功とし、そうでなければ失敗とする。

### まとめ

発表を聞いて作ってみたい気持ちが高まっていたので、盆休みの宿題として正規表現エンジンを作ってみた。
DFAベースのエンジンとVMベースのエンジンがどのように作られているのかということ、そこからどのような特徴があるのかということが理解できて良かった。

今後の展望としては、最後に微分ベースのエンジンを作ってみたいと思っている。Rubyではない別の言語で実装してみるのも面白そう。
